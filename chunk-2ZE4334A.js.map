{"version":3,"sources":[".yarn/__virtual__/@angular-cdk-virtual-a01d2682d6/0/cache/@angular-cdk-npm-18.2.7-c495f53e2a-bd97836f56.zip/node_modules/@angular/cdk/fesm2022/collections.mjs",".yarn/__virtual__/@angular-cdk-virtual-a01d2682d6/0/cache/@angular-cdk-npm-18.2.7-c495f53e2a-bd97836f56.zip/node_modules/@angular/cdk/fesm2022/portal.mjs"],"sourcesContent":["import { ConnectableObservable, isObservable, of, Subject } from 'rxjs';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable } from '@angular/core';\nclass DataSource {}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n  // Check if the value is a DataSource by observing if it has a connect function. Cannot\n  // be checked as an `instanceof DataSource` since people could create their own sources\n  // that match the interface, but don't extend DataSource. We also can't use `isObservable`\n  // here, because of some internal apps.\n  return value && typeof value.connect === 'function' && !(value instanceof ConnectableObservable);\n}\n\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n  constructor(_data) {\n    super();\n    this._data = _data;\n  }\n  connect() {\n    return isObservable(this._data) ? this._data : of(this._data);\n  }\n  disconnect() {}\n}\n\n/** Indicates how a view was changed by a {@link _ViewRepeater}. */\nvar _ViewRepeaterOperation = /*#__PURE__*/function (_ViewRepeaterOperation) {\n  /** The content of an existing view was replaced with another item. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REPLACED\"] = 0] = \"REPLACED\";\n  /** A new view was created with `createEmbeddedView`. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"INSERTED\"] = 1] = \"INSERTED\";\n  /** The position of a view changed, but the content remains the same. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"MOVED\"] = 2] = \"MOVED\";\n  /** A view was detached from the view container. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REMOVED\"] = 3] = \"REMOVED\";\n  return _ViewRepeaterOperation;\n}(_ViewRepeaterOperation || {});\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = /*#__PURE__*/new InjectionToken('_ViewRepeater');\n\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n      let view;\n      let operation;\n      if (record.previousIndex == null) {\n        const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n        view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n        operation = _ViewRepeaterOperation.INSERTED;\n      } else if (currentIndex == null) {\n        viewContainerRef.remove(adjustedPreviousIndex);\n        operation = _ViewRepeaterOperation.REMOVED;\n      } else {\n        view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        operation = _ViewRepeaterOperation.MOVED;\n      }\n      if (itemViewChanged) {\n        itemViewChanged({\n          context: view?.context,\n          operation,\n          record\n        });\n      }\n    });\n  }\n  detach() {}\n}\n\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n  constructor() {\n    /**\n     * The size of the cache used to store unused views.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n     */\n    this.viewCacheSize = 20;\n    /**\n     * View cache that stores embedded view instances that have been previously stamped out,\n     * but don't are not currently rendered. The view repeater will reuse these views rather than\n     * creating brand new ones.\n     *\n     * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n     */\n    this._viewCache = [];\n  }\n  /** Apply changes to the DOM. */\n  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n    // Rearrange the views to put them in the right location.\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n      let view;\n      let operation;\n      if (record.previousIndex == null) {\n        // Item added.\n        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\n      } else if (currentIndex == null) {\n        // Item removed.\n        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n        operation = _ViewRepeaterOperation.REMOVED;\n      } else {\n        // Item moved.\n        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = _ViewRepeaterOperation.MOVED;\n      }\n      if (itemViewChanged) {\n        itemViewChanged({\n          context: view?.context,\n          operation,\n          record\n        });\n      }\n    });\n  }\n  detach() {\n    for (const view of this._viewCache) {\n      view.destroy();\n    }\n    this._viewCache = [];\n  }\n  /**\n   * Inserts a view for a new item, either from the cache or by creating a new\n   * one. Returns `undefined` if the item was inserted into a cached view.\n   */\n  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n    if (cachedView) {\n      cachedView.context.$implicit = value;\n      return undefined;\n    }\n    const viewArgs = viewArgsFactory();\n    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n  }\n  /** Detaches the view at the given index and inserts into the view cache. */\n  _detachAndCacheView(index, viewContainerRef) {\n    const detachedView = viewContainerRef.detach(index);\n    this._maybeCacheView(detachedView, viewContainerRef);\n  }\n  /** Moves view at the previous index to the current index. */\n  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n    const view = viewContainerRef.get(adjustedPreviousIndex);\n    viewContainerRef.move(view, currentIndex);\n    view.context.$implicit = value;\n    return view;\n  }\n  /**\n   * Cache the given detached view. If the cache is full, the view will be\n   * destroyed.\n   */\n  _maybeCacheView(view, viewContainerRef) {\n    if (this._viewCache.length < this.viewCacheSize) {\n      this._viewCache.push(view);\n    } else {\n      const index = viewContainerRef.indexOf(view);\n      // The host component could remove views from the container outside of\n      // the view repeater. It's unlikely this will occur, but just in case,\n      // destroy the view on its own, otherwise destroy it through the\n      // container to ensure that all the references are removed.\n      if (index === -1) {\n        view.destroy();\n      } else {\n        viewContainerRef.remove(index);\n      }\n    }\n  }\n  /** Inserts a recycled view from the cache at the given index. */\n  _insertViewFromCache(index, viewContainerRef) {\n    const cachedView = this._viewCache.pop();\n    if (cachedView) {\n      viewContainerRef.insert(cachedView, index);\n    }\n    return cachedView || null;\n  }\n}\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n  /** Selected values. */\n  get selected() {\n    if (!this._selected) {\n      this._selected = Array.from(this._selection.values());\n    }\n    return this._selected;\n  }\n  constructor(_multiple = false, initiallySelectedValues, _emitChanges = true, compareWith) {\n    this._multiple = _multiple;\n    this._emitChanges = _emitChanges;\n    this.compareWith = compareWith;\n    /** Currently-selected values. */\n    this._selection = new Set();\n    /** Keeps track of the deselected options that haven't been emitted by the change event. */\n    this._deselectedToEmit = [];\n    /** Keeps track of the selected options that haven't been emitted by the change event. */\n    this._selectedToEmit = [];\n    /** Event emitted when the value has changed. */\n    this.changed = new Subject();\n    if (initiallySelectedValues && initiallySelectedValues.length) {\n      if (_multiple) {\n        initiallySelectedValues.forEach(value => this._markSelected(value));\n      } else {\n        this._markSelected(initiallySelectedValues[0]);\n      }\n      // Clear the array in order to avoid firing the change event for preselected values.\n      this._selectedToEmit.length = 0;\n    }\n  }\n  /**\n   * Selects a value or an array of values.\n   * @param values The values to select\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  select(...values) {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._markSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n  /**\n   * Deselects a value or an array of values.\n   * @param values The values to deselect\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  deselect(...values) {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n  /**\n   * Sets the selected values\n   * @param values The new selected values\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  setSelection(...values) {\n    this._verifyValueAssignment(values);\n    const oldValues = this.selected;\n    const newSelectedSet = new Set(values);\n    values.forEach(value => this._markSelected(value));\n    oldValues.filter(value => !newSelectedSet.has(this._getConcreteValue(value, newSelectedSet))).forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n  /**\n   * Toggles a value between selected and deselected.\n   * @param value The value to toggle\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  toggle(value) {\n    return this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n  /**\n   * Clears all of the selected values.\n   * @param flushEvent Whether to flush the changes in an event.\n   *   If false, the changes to the selection will be flushed along with the next event.\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  clear(flushEvent = true) {\n    this._unmarkAll();\n    const changed = this._hasQueuedChanges();\n    if (flushEvent) {\n      this._emitChangeEvent();\n    }\n    return changed;\n  }\n  /**\n   * Determines whether a value is selected.\n   */\n  isSelected(value) {\n    return this._selection.has(this._getConcreteValue(value));\n  }\n  /**\n   * Determines whether the model does not have a value.\n   */\n  isEmpty() {\n    return this._selection.size === 0;\n  }\n  /**\n   * Determines whether the model has a value.\n   */\n  hasValue() {\n    return !this.isEmpty();\n  }\n  /**\n   * Sorts the selected values based on a predicate function.\n   */\n  sort(predicate) {\n    if (this._multiple && this.selected) {\n      this._selected.sort(predicate);\n    }\n  }\n  /**\n   * Gets whether multiple values can be selected.\n   */\n  isMultipleSelection() {\n    return this._multiple;\n  }\n  /** Emits a change event and clears the records of selected and deselected values. */\n  _emitChangeEvent() {\n    // Clear the selected values so they can be re-cached.\n    this._selected = null;\n    if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n      this.changed.next({\n        source: this,\n        added: this._selectedToEmit,\n        removed: this._deselectedToEmit\n      });\n      this._deselectedToEmit = [];\n      this._selectedToEmit = [];\n    }\n  }\n  /** Selects a value. */\n  _markSelected(value) {\n    value = this._getConcreteValue(value);\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n      if (!this.isSelected(value)) {\n        this._selection.add(value);\n      }\n      if (this._emitChanges) {\n        this._selectedToEmit.push(value);\n      }\n    }\n  }\n  /** Deselects a value. */\n  _unmarkSelected(value) {\n    value = this._getConcreteValue(value);\n    if (this.isSelected(value)) {\n      this._selection.delete(value);\n      if (this._emitChanges) {\n        this._deselectedToEmit.push(value);\n      }\n    }\n  }\n  /** Clears out the selected values. */\n  _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selection.forEach(value => this._unmarkSelected(value));\n    }\n  }\n  /**\n   * Verifies the value assignment and throws an error if the specified value array is\n   * including multiple values while the selection model is not supporting multiple values.\n   */\n  _verifyValueAssignment(values) {\n    if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMultipleValuesInSingleSelectionError();\n    }\n  }\n  /** Whether there are queued up change to be emitted. */\n  _hasQueuedChanges() {\n    return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n  }\n  /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */\n  _getConcreteValue(inputValue, selection) {\n    if (!this.compareWith) {\n      return inputValue;\n    } else {\n      selection = selection ?? this._selection;\n      for (let selectedValue of selection) {\n        if (this.compareWith(inputValue, selectedValue)) {\n          return selectedValue;\n        }\n      }\n      return inputValue;\n    }\n  }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n  return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nlet UniqueSelectionDispatcher = /*#__PURE__*/(() => {\n  class UniqueSelectionDispatcher {\n    constructor() {\n      this._listeners = [];\n    }\n    /**\n     * Notify other items that selection for the given name has been set.\n     * @param id ID of the item.\n     * @param name Name of the item.\n     */\n    notify(id, name) {\n      for (let listener of this._listeners) {\n        listener(id, name);\n      }\n    }\n    /**\n     * Listen for future changes to item selection.\n     * @return Function used to deregister listener\n     */\n    listen(listener) {\n      this._listeners.push(listener);\n      return () => {\n        this._listeners = this._listeners.filter(registered => {\n          return listener !== registered;\n        });\n      };\n    }\n    ngOnDestroy() {\n      this._listeners = [];\n    }\n    static {\n      this.ɵfac = function UniqueSelectionDispatcher_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || UniqueSelectionDispatcher)();\n      };\n    }\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: UniqueSelectionDispatcher,\n        factory: UniqueSelectionDispatcher.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return UniqueSelectionDispatcher;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ArrayDataSource, DataSource, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, _ViewRepeaterOperation, getMultipleValuesInSingleSelectionError, isDataSource };\n","import * as i0 from '@angular/core';\nimport { ElementRef, Injector, Directive, EventEmitter, Inject, Input, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nfunction throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n  /** Attach this portal to a host. */\n  attach(host) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n    }\n    this._attachedHost = host;\n    return host.attach(this);\n  }\n  /** Detach this portal from its host */\n  detach() {\n    let host = this._attachedHost;\n    if (host != null) {\n      this._attachedHost = null;\n      host.detach();\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwNoPortalAttachedError();\n    }\n  }\n  /** Whether this portal is attached to a host. */\n  get isAttached() {\n    return this._attachedHost != null;\n  }\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host) {\n    this._attachedHost = host;\n  }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n  constructor(component, viewContainerRef, injector, componentFactoryResolver, projectableNodes) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.projectableNodes = projectableNodes;\n  }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n  constructor(/** The embedded template that will be used to instantiate an embedded View in the host. */\n  templateRef, /** Reference to the ViewContainer into which the template will be stamped out. */\n  viewContainerRef, /** Contextual data to be passed in to the embedded view. */\n  context, /** The injector to use for the embedded view. */\n  injector) {\n    super();\n    this.templateRef = templateRef;\n    this.viewContainerRef = viewContainerRef;\n    this.context = context;\n    this.injector = injector;\n  }\n  get origin() {\n    return this.templateRef.elementRef;\n  }\n  /**\n   * Attach the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  attach(host, context = this.context) {\n    this.context = context;\n    return super.attach(host);\n  }\n  detach() {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass DomPortal extends Portal {\n  constructor(element) {\n    super();\n    this.element = element instanceof ElementRef ? element.nativeElement : element;\n  }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n  constructor() {\n    /** Whether this host has already been permanently disposed. */\n    this._isDisposed = false;\n    // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n    this.attachDomPortal = null;\n  }\n  /** Whether this host has an attached portal. */\n  hasAttached() {\n    return !!this._attachedPortal;\n  }\n  /** Attaches a portal. */\n  attach(portal) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n    }\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n      // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n    } else if (this.attachDomPortal && portal instanceof DomPortal) {\n      this._attachedPortal = portal;\n      return this.attachDomPortal(portal);\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwUnknownPortalTypeError();\n    }\n  }\n  /** Detaches a previously attached portal. */\n  detach() {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n    this._invokeDisposeFn();\n  }\n  /** Permanently dispose of this portal host. */\n  dispose() {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n  /** @docs-private */\n  setDisposeFn(fn) {\n    this._disposeFn = fn;\n  }\n  _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {}\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n  /**\n   * @param outletElement Element into which the content is projected.\n   * @param _componentFactoryResolver Used to resolve the component factory.\n   *   Only required when attaching component portals.\n   * @param _appRef Reference to the application. Only used in component portals when there\n   *   is no `ViewContainerRef` available.\n   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't\n   *   have one. Only used for component portals.\n   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually\n   *   become a required parameter.\n   */\n  constructor(/** Element into which the content is projected. */\n  outletElement, _componentFactoryResolver, _appRef, _defaultInjector,\n  /**\n   * @deprecated `_document` Parameter to be made required.\n   * @breaking-change 10.0.0\n   */\n  _document) {\n    super();\n    this.outletElement = outletElement;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._appRef = _appRef;\n    this._defaultInjector = _defaultInjector;\n    /**\n     * Attaches a DOM portal by transferring its content into the outlet.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    this.attachDomPortal = portal => {\n      // @breaking-change 10.0.0 Remove check and error once the\n      // `_document` constructor parameter is required.\n      if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Cannot attach DOM portal without _document constructor parameter');\n      }\n      const element = portal.element;\n      if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('DOM portal content must be attached to a parent node.');\n      }\n      // Anchor used to save the element's previous position so\n      // that we can restore it when the portal is detached.\n      const anchorNode = this._document.createComment('dom-portal');\n      element.parentNode.insertBefore(anchorNode, element);\n      this.outletElement.appendChild(element);\n      this._attachedPortal = portal;\n      super.setDisposeFn(() => {\n        // We can't use `replaceWith` here because IE doesn't support it.\n        if (anchorNode.parentNode) {\n          anchorNode.parentNode.replaceChild(element, anchorNode);\n        }\n      });\n    };\n    this._document = _document;\n  }\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal(portal) {\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !resolver) {\n      throw Error('Cannot attach component portal to outlet without a ComponentFactoryResolver.');\n    }\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    let componentRef;\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, portal.projectableNodes || undefined);\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && !this._appRef) {\n        throw Error('Cannot attach component portal to outlet without an ApplicationRef.');\n      }\n      componentRef = componentFactory.create(portal.injector || this._defaultInjector || Injector.NULL);\n      this._appRef.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        // Verify that the ApplicationRef has registered views before trying to detach a host view.\n        // This check also protects the `detachView` from being called on a destroyed ApplicationRef.\n        if (this._appRef.viewCount > 0) {\n          this._appRef.detachView(componentRef.hostView);\n        }\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n    this._attachedPortal = portal;\n    return componentRef;\n  }\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal(portal) {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {\n      injector: portal.injector\n    });\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n    // Note that we want to detect changes after the nodes have been moved so that\n    // any directives inside the portal that are looking at the DOM inside a lifecycle\n    // hook won't be invoked too early.\n    viewRef.detectChanges();\n    this.setDisposeFn(() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    });\n    this._attachedPortal = portal;\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n  /**\n   * Clears out a portal from the DOM.\n   */\n  dispose() {\n    super.dispose();\n    this.outletElement.remove();\n  }\n  /** Gets the root HTMLElement for an instantiated component. */\n  _getComponentRootNode(componentRef) {\n    return componentRef.hostView.rootNodes[0];\n  }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {}\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nlet CdkPortal = /*#__PURE__*/(() => {\n  class CdkPortal extends TemplatePortal {\n    constructor(templateRef, viewContainerRef) {\n      super(templateRef, viewContainerRef);\n    }\n    static {\n      this.ɵfac = function CdkPortal_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || CdkPortal)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n      };\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: CdkPortal,\n        selectors: [[\"\", \"cdkPortal\", \"\"]],\n        exportAs: [\"cdkPortal\"],\n        standalone: true,\n        features: [i0.ɵɵInheritDefinitionFeature]\n      });\n    }\n  }\n  return CdkPortal;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\nlet TemplatePortalDirective = /*#__PURE__*/(() => {\n  class TemplatePortalDirective extends CdkPortal {\n    static {\n      this.ɵfac = /* @__PURE__ */(() => {\n        let ɵTemplatePortalDirective_BaseFactory;\n        return function TemplatePortalDirective_Factory(__ngFactoryType__) {\n          return (ɵTemplatePortalDirective_BaseFactory || (ɵTemplatePortalDirective_BaseFactory = i0.ɵɵgetInheritedFactory(TemplatePortalDirective)))(__ngFactoryType__ || TemplatePortalDirective);\n        };\n      })();\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: TemplatePortalDirective,\n        selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]],\n        exportAs: [\"cdkPortal\"],\n        standalone: true,\n        features: [i0.ɵɵProvidersFeature([{\n          provide: CdkPortal,\n          useExisting: TemplatePortalDirective\n        }]), i0.ɵɵInheritDefinitionFeature]\n      });\n    }\n  }\n  return TemplatePortalDirective;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nlet CdkPortalOutlet = /*#__PURE__*/(() => {\n  class CdkPortalOutlet extends BasePortalOutlet {\n    constructor(_componentFactoryResolver, _viewContainerRef,\n    /**\n     * @deprecated `_document` parameter to be made required.\n     * @breaking-change 9.0.0\n     */\n    _document) {\n      super();\n      this._componentFactoryResolver = _componentFactoryResolver;\n      this._viewContainerRef = _viewContainerRef;\n      /** Whether the portal component is initialized. */\n      this._isInitialized = false;\n      /** Emits when a portal is attached to the outlet. */\n      this.attached = new EventEmitter();\n      /**\n       * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n       * @param portal Portal to be attached.\n       * @deprecated To be turned into a method.\n       * @breaking-change 10.0.0\n       */\n      this.attachDomPortal = portal => {\n        // @breaking-change 9.0.0 Remove check and error once the\n        // `_document` constructor parameter is required.\n        if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw Error('Cannot attach DOM portal without _document constructor parameter');\n        }\n        const element = portal.element;\n        if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw Error('DOM portal content must be attached to a parent node.');\n        }\n        // Anchor used to save the element's previous position so\n        // that we can restore it when the portal is detached.\n        const anchorNode = this._document.createComment('dom-portal');\n        portal.setAttachedHost(this);\n        element.parentNode.insertBefore(anchorNode, element);\n        this._getRootNode().appendChild(element);\n        this._attachedPortal = portal;\n        super.setDisposeFn(() => {\n          if (anchorNode.parentNode) {\n            anchorNode.parentNode.replaceChild(element, anchorNode);\n          }\n        });\n      };\n      this._document = _document;\n    }\n    /** Portal associated with the Portal outlet. */\n    get portal() {\n      return this._attachedPortal;\n    }\n    set portal(portal) {\n      // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n      // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n      // and attach a portal programmatically in the parent component. When Angular does the first CD\n      // round, it will fire the setter with empty string, causing the user's content to be cleared.\n      if (this.hasAttached() && !portal && !this._isInitialized) {\n        return;\n      }\n      if (this.hasAttached()) {\n        super.detach();\n      }\n      if (portal) {\n        super.attach(portal);\n      }\n      this._attachedPortal = portal || null;\n    }\n    /** Component or view reference that is attached to the portal. */\n    get attachedRef() {\n      return this._attachedRef;\n    }\n    ngOnInit() {\n      this._isInitialized = true;\n    }\n    ngOnDestroy() {\n      super.dispose();\n      this._attachedRef = this._attachedPortal = null;\n    }\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n      portal.setAttachedHost(this);\n      // If the portal specifies an origin, use that as the logical location of the component\n      // in the application tree. Otherwise use the location of this PortalOutlet.\n      const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n      const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n      const componentFactory = resolver.resolveComponentFactory(portal.component);\n      const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector, portal.projectableNodes || undefined);\n      // If we're using a view container that's different from the injected one (e.g. when the portal\n      // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n      // inside of the alternate view container.\n      if (viewContainerRef !== this._viewContainerRef) {\n        this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n      }\n      super.setDisposeFn(() => ref.destroy());\n      this._attachedPortal = portal;\n      this._attachedRef = ref;\n      this.attached.emit(ref);\n      return ref;\n    }\n    /**\n     * Attach the given TemplatePortal to this PortalHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n      portal.setAttachedHost(this);\n      const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {\n        injector: portal.injector\n      });\n      super.setDisposeFn(() => this._viewContainerRef.clear());\n      this._attachedPortal = portal;\n      this._attachedRef = viewRef;\n      this.attached.emit(viewRef);\n      return viewRef;\n    }\n    /** Gets the root node of the portal outlet. */\n    _getRootNode() {\n      const nativeElement = this._viewContainerRef.element.nativeElement;\n      // The directive could be set on a template which will result in a comment\n      // node being the root. Use the comment's parent node if that is the case.\n      return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;\n    }\n    static {\n      this.ɵfac = function CdkPortalOutlet_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || CdkPortalOutlet)(i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DOCUMENT));\n      };\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: CdkPortalOutlet,\n        selectors: [[\"\", \"cdkPortalOutlet\", \"\"]],\n        inputs: {\n          portal: [0, \"cdkPortalOutlet\", \"portal\"]\n        },\n        outputs: {\n          attached: \"attached\"\n        },\n        exportAs: [\"cdkPortalOutlet\"],\n        standalone: true,\n        features: [i0.ɵɵInheritDefinitionFeature]\n      });\n    }\n  }\n  return CdkPortalOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nlet PortalHostDirective = /*#__PURE__*/(() => {\n  class PortalHostDirective extends CdkPortalOutlet {\n    static {\n      this.ɵfac = /* @__PURE__ */(() => {\n        let ɵPortalHostDirective_BaseFactory;\n        return function PortalHostDirective_Factory(__ngFactoryType__) {\n          return (ɵPortalHostDirective_BaseFactory || (ɵPortalHostDirective_BaseFactory = i0.ɵɵgetInheritedFactory(PortalHostDirective)))(__ngFactoryType__ || PortalHostDirective);\n        };\n      })();\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: PortalHostDirective,\n        selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]],\n        inputs: {\n          portal: [0, \"cdkPortalHost\", \"portal\"]\n        },\n        exportAs: [\"cdkPortalHost\"],\n        standalone: true,\n        features: [i0.ɵɵProvidersFeature([{\n          provide: CdkPortalOutlet,\n          useExisting: PortalHostDirective\n        }]), i0.ɵɵInheritDefinitionFeature]\n      });\n    }\n  }\n  return PortalHostDirective;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PortalModule = /*#__PURE__*/(() => {\n  class PortalModule {\n    static {\n      this.ɵfac = function PortalModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || PortalModule)();\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: PortalModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return PortalModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nclass PortalInjector {\n  constructor(_parentInjector, _customTokens) {\n    this._parentInjector = _parentInjector;\n    this._customTokens = _customTokens;\n  }\n  get(token, notFoundValue) {\n    const value = this._customTokens.get(token);\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n    return this._parentInjector.get(token, notFoundValue);\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BasePortalHost, BasePortalOutlet, CdkPortal, CdkPortalOutlet, ComponentPortal, DomPortal, DomPortalHost, DomPortalOutlet, Portal, PortalHostDirective, PortalInjector, PortalModule, TemplatePortal, TemplatePortalDirective };\n"],"mappings":"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","names":["isDataSource","value","ConnectableObservable","_ViewRepeaterOperation","_VIEW_REPEATER_STRATEGY","InjectionToken","_DisposeViewRepeaterStrategy","changes","viewContainerRef","itemContextFactory","itemValueResolver","itemViewChanged","record","adjustedPreviousIndex","currentIndex","view","operation","insertContext","UniqueSelectionDispatcher","_UniqueSelectionDispatcher","id","name","listener","registered","__ngFactoryType__","ɵɵdefineInjectable","Portal","host","ComponentPortal","component","viewContainerRef","injector","componentFactoryResolver","projectableNodes","TemplatePortal","templateRef","context","DomPortal","element","ElementRef","BasePortalOutlet","portal","fn","DomPortalOutlet","BasePortalOutlet","outletElement","_componentFactoryResolver","_appRef","_defaultInjector","_document","portal","element","anchorNode","componentFactory","componentRef","Injector","viewContainer","viewRef","rootNode","index","CdkPortalOutlet","_CdkPortalOutlet","BasePortalOutlet","_componentFactoryResolver","_viewContainerRef","_document","EventEmitter","portal","element","anchorNode","viewContainerRef","componentFactory","ref","viewRef","nativeElement","__ngFactoryType__","ɵɵdirectiveInject","ComponentFactoryResolver$1","ViewContainerRef","DOCUMENT","ɵɵdefineDirective","ɵɵInheritDefinitionFeature","PortalModule","_PortalModule","__ngFactoryType__","ɵɵdefineNgModule","ɵɵdefineInjector"],"x_google_ignoreList":[0,1]}