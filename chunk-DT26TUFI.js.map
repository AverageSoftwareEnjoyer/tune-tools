{
  "version": 3,
  "sources": ["src/environments/environment.ts", "src/app/api/auth-http.service.ts", "src/environments/environment.development.ts", "src/app/state/auth.state.service.ts", "src/app/models/local-storage.model.ts", "src/app/core/auth/local-storage.service.ts", "src/app/core/auth/auth.service.ts"],
  "sourcesContent": ["import { Environment } from \"../app/models/environment.model\";\n\nexport const environment: Environment = {\n    production: true,\n    clientId: \"d9716dd3efb4408491738456849796a1\",\n    redirectUri:\n        \"https://averagesoftwareenjoyer.github.io/tune-tools/auth-callback\",\n    scope: \"playlist-modify-private playlist-modify-public user-read-private user-read-recently-played user-top-read\",\n    authUrl: \"https://accounts.spotify.com/authorize\",\n    tokenUrl: \"https://accounts.spotify.com/api/token\",\n};\n", "import { HttpClient, HttpParams } from \"@angular/common/http\";\nimport { inject, Injectable } from \"@angular/core\";\nimport { TokenResponse } from \"@dto/spotify\";\nimport { environment } from \"@env/environment\";\nimport { Observable } from \"rxjs\";\n\n@Injectable({\n    providedIn: \"root\",\n})\nexport class AuthHTTPService {\n    readonly #httpClient = inject(HttpClient);\n\n    /**\n     * Retrieves an access token using an authorization code and verifier.\n     *\n     * @param verifier - The code verifier used in the PKCE flow.\n     * @param code - The authorization code received from the authorization server.\n     * @returns An Observable that emits the `TokenResponse`.\n     */\n    getAccessToken$(verifier: string, code: string): Observable<TokenResponse> {\n        const params = new HttpParams()\n            .set(\"client_id\", environment.clientId)\n            .set(\"grant_type\", \"authorization_code\")\n            .set(\"redirect_uri\", environment.redirectUri)\n            .set(\"code\", code)\n            .set(\"code_verifier\", verifier);\n\n        return this.#httpClient.post<TokenResponse>(\n            environment.tokenUrl,\n            params,\n            {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                },\n            },\n        );\n    }\n\n    /**\n     * Refreshes the access token using a refresh token.\n     *\n     * @param refreshToken - The refresh token used to obtain a new access token.\n     * @returns An Observable that emits the `TokenResponse`.\n     */\n    refreshAccessToken$(refreshToken: string): Observable<TokenResponse> {\n        const params = new HttpParams()\n            .set(\"client_id\", environment.clientId)\n            .set(\"grant_type\", \"refresh_token\")\n            .set(\"refresh_token\", refreshToken);\n\n        return this.#httpClient.post<TokenResponse>(\n            environment.tokenUrl,\n            params,\n            {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                },\n            },\n        );\n    }\n}\n", "import { Environment } from \"../app/models/environment.model\";\n\nexport const environment: Environment = {\n    production: false,\n    clientId: \"d9716dd3efb4408491738456849796a1\",\n    redirectUri: \"http://localhost:4200/auth-callback\",\n    scope: \"playlist-modify-private playlist-modify-public user-read-private user-read-recently-played user-top-read\",\n    authUrl: \"https://accounts.spotify.com/authorize\",\n    tokenUrl: \"https://accounts.spotify.com/api/token\",\n};\n", "import { Injectable } from \"@angular/core\";\n\n@Injectable({\n    providedIn: \"root\",\n})\nexport class AuthStateService {\n    #isUserAuthenticated = false;\n    #isUserAuthorized = false;\n\n    get isUserAuthenticated(): boolean {\n        return this.#isUserAuthenticated;\n    }\n\n    set isUserAuthenticated(value: boolean) {\n        this.#isUserAuthenticated = value;\n    }\n\n    get isUserAuthorized(): boolean {\n        return this.#isUserAuthorized;\n    }\n\n    set isUserAuthorized(value: boolean) {\n        this.#isUserAuthorized = value;\n    }\n}\n", "export const KEYS = [\n    \"verifier\",\n    \"access_token\",\n    \"refresh_token\",\n    \"token_expiry\",\n    \"state\",\n] as const;\n\nexport type Key = (typeof KEYS)[number];\n", "import { Injectable } from \"@angular/core\";\nimport { Key, KEYS } from \"@models/local-storage.model\";\n\n@Injectable({\n    providedIn: \"root\",\n})\nexport class LocalStorageService {\n    /**\n     * Sets a string value in localStorage with a given key.\n     *\n     * @param key - The key under which the value is stored.\n     * @param value - The string value to be stored.\n     */\n    setItem(key: Key, value: string): void {\n        localStorage.setItem(`__${key}`, value);\n    }\n\n    /**\n     * Retrieves a string value from localStorage by key.\n     *\n     * @param key - The key under which the value is stored.\n     * @returns The string value if found, otherwise null.\n     */\n    getItem(key: Key): string | null {\n        return localStorage.getItem(`__${key}`);\n    }\n\n    /**\n     * Removes an item from localStorage by key.\n     *\n     * @param key - The key of the item to remove.\n     */\n    removeItem(key: Key): void {\n        localStorage.removeItem(`__${key}`);\n    }\n\n    /**\n     * Clears all specified keys from localStorage.\n     * Iterates over a predefined list of keys and removes each one.\n     */\n    clearLocalStorageItems(): void {\n        for (const key of KEYS) {\n            this.removeItem(key);\n        }\n    }\n}\n", "import { HttpParams } from \"@angular/common/http\";\nimport { inject, Injectable } from \"@angular/core\";\nimport { ActivatedRoute, Router } from \"@angular/router\";\nimport { AuthHTTPService } from \"@api/auth-http.service\";\nimport { environment } from \"@env/environment.development\";\nimport { AuthStateService } from \"@state/auth.state.service\";\nimport {\n    catchError,\n    EMPTY,\n    finalize,\n    forkJoin,\n    from,\n    map,\n    Observable,\n    of,\n    switchMap,\n    tap,\n} from \"rxjs\";\n\nimport { LocalStorageService } from \"./local-storage.service\";\n\n@Injectable({\n    providedIn: \"root\",\n})\nexport class AuthService {\n    readonly #activatedRoute = inject(ActivatedRoute);\n    readonly #authHTTPService = inject(AuthHTTPService);\n    readonly #authStateService = inject(AuthStateService);\n    readonly #localStorageService = inject(LocalStorageService);\n    readonly #router = inject(Router);\n\n    /**\n     * Generates a random string of a given length using characters from a specified set.\n     *\n     * @param length - The length of the random string to generate.\n     * @returns A random string of the specified length.\n     */\n    generateRandomString(length: number): string {\n        const possible =\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        const values = crypto.getRandomValues(new Uint8Array(length));\n        return values.reduce(\n            (acc, x) => acc + possible[x % possible.length],\n            \"\",\n        );\n    }\n\n    /**\n     * Computes the SHA-256 hash of a given string.\n     *\n     * @param plain - The plain text string to hash.\n     * @returns An Observable that emits the resulting ArrayBuffer of the hash.\n     */\n    sha256$(plain: string): Observable<ArrayBuffer> {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(plain);\n        return from(crypto.subtle.digest(\"SHA-256\", data));\n    }\n\n    /**\n     * Encodes an ArrayBuffer to a base64 URL-safe string.\n     *\n     * @param input - The ArrayBuffer to encode.\n     * @returns A base64 URL-safe encoded string.\n     */\n    base64encode(input: ArrayBuffer): string {\n        return btoa(String.fromCharCode(...new Uint8Array(input)))\n            .replace(/=/g, \"\")\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\");\n    }\n\n    /**\n     * Redirects the user to the authorization code flow.\n     *\n     * Generates a random verifier and state, computes their SHA-256 hashes,\n     * encodes them to base64 URL-safe strings, and constructs the authorization URL.\n     * It also stores the verifier and state in local storage and finally redirects the user\n     * to the constructed authorization URL.\n     *\n     * @returns An Observable that emits a boolean indicating the operation status.\n     */\n    redirectToAuthCodeFlow$(): Observable<boolean> {\n        let redirectURL: string;\n        const verifier = this.generateRandomString(128);\n        const state = this.generateRandomString(128);\n        return forkJoin([this.sha256$(verifier), this.sha256$(state)]).pipe(\n            map(([verifierArray, stateArray]) => [\n                this.base64encode(verifierArray),\n                this.base64encode(stateArray),\n            ]),\n            tap(([, authState]) => {\n                this.#localStorageService.setItem(\"verifier\", verifier);\n                this.#localStorageService.setItem(\"state\", authState);\n            }),\n            tap(([code, authState]) => {\n                const params = new HttpParams()\n                    .set(\"client_id\", environment.clientId)\n                    .set(\"response_type\", \"code\")\n                    .set(\"redirect_uri\", environment.redirectUri)\n                    .set(\"scope\", environment.scope)\n                    .set(\"code_challenge_method\", \"S256\")\n                    .set(\"code_challenge\", code)\n                    .set(\"state\", authState);\n                debugger;\n                redirectURL = `${environment.authUrl}?${params.toString()}`;\n            }),\n            map(() => false),\n            finalize(() => (window.location.href = redirectURL)),\n        );\n    }\n\n    /**\n     * Handles the authorization callback by processing query parameters.\n     *\n     * Checks the authorization code and state from the query parameters\n     * against the stored state. If the state matches, it proceeds to obtain the access token.\n     * If the state does not match or is missing, it clears the local storage and redirects the user.\n     *\n     * @returns An Observable that emits a boolean indicating the success or failure of the operation.\n     */\n    handleAuthCallback$(): Observable<boolean> {\n        return this.#activatedRoute.queryParams.pipe(\n            switchMap(({ code, state }: { code?: string; state?: string }) => {\n                if (\n                    !code ||\n                    !state ||\n                    state !== this.#localStorageService.getItem(\"state\")\n                ) {\n                    this.#localStorageService.clearLocalStorageItems();\n                    return from(this.#router.navigateByUrl(\"\"));\n                }\n                this.#localStorageService.removeItem(\"state\");\n                return this.getAccessTokenWrapper$(code);\n            }),\n        );\n    }\n\n    /**\n     * Wraps the process of obtaining an access token using an authorization code.\n     *\n     * Retrieves the stored code verifier from local storage, and if the verifier is not found,\n     * it clears the local storage and redirects the user. If the verifier is found, it proceeds to request\n     * the access token using the provided authorization code. On success, it handles the authentication and\n     * removes the verifier from local storage. On error, it clears the local storage and redirects the user.\n     *\n     * @param code - The authorization code received from the authorization server.\n     * @returns An Observable that emits a boolean indicating the success or failure of the operation.\n     */\n    getAccessTokenWrapper$(code: string): Observable<boolean> {\n        // TODO: Include in header interceptor\n        const verifier = this.#localStorageService.getItem(\"verifier\");\n        if (!verifier) {\n            this.#authStateService.isUserAuthenticated = false;\n            this.#localStorageService.clearLocalStorageItems();\n            return from(this.#router.navigateByUrl(\"\"));\n        }\n\n        return this.#authHTTPService.getAccessToken$(verifier, code).pipe(\n            catchError(() => {\n                this.#authStateService.isUserAuthenticated = false;\n                this.#localStorageService.clearLocalStorageItems();\n                return from(this.#router.navigateByUrl(\"\")).pipe(\n                    switchMap(() => EMPTY),\n                );\n            }),\n            tap(({ access_token, refresh_token }) => {\n                this.#handleAuthentication(access_token, refresh_token);\n                this.#localStorageService.removeItem(\"verifier\");\n            }),\n            // TODO: Navigate to the requested URL instead\n            switchMap(() => from(this.#router.navigateByUrl(\"/top-tracks\"))),\n        );\n    }\n\n    /**\n     * Handles the case of a potentially expired access token.\n     *\n     * Checks if the access token, refresh token, and token expiry are present in local storage.\n     * If any of these are missing, it clears the local storage and redirects the user. If the access token\n     * is expired, it attempts to refresh the access token using the refresh token. If the access token is not\n     * expired, it does nothing.\n     *\n     * @returns An Observable that emits a boolean indicating the success or failure of the operation.\n     */\n    handlePotentiallyExpiredAccessToken$(): Observable<boolean> {\n        // TODO: Include in header interceptor\n        const accessToken = this.#localStorageService.getItem(\"access_token\");\n        const refreshToken = this.#localStorageService.getItem(\"refresh_token\");\n        const expiry = this.#localStorageService.getItem(\"token_expiry\");\n\n        if (!accessToken || !refreshToken || !expiry) {\n            this.#authStateService.isUserAuthenticated = false;\n            this.#localStorageService.clearLocalStorageItems();\n            return from(this.#router.navigateByUrl(\"\"));\n        }\n        if (new Date() > new Date(parseInt(expiry))) {\n            return this.#authHTTPService.refreshAccessToken$(refreshToken).pipe(\n                tap(({ access_token, refresh_token }) =>\n                    this.#handleAuthentication(access_token, refresh_token),\n                ),\n                map(() => false),\n            );\n        }\n        return of(false);\n    }\n\n    /**\n     * Handles authentication by storing the access token, refresh token, and token expiry time in\n     * local storage.\n     *\n     * @param accessToken - The access token to store.\n     * @param refreshToken - The refresh token to store.\n     */\n    #handleAuthentication(accessToken: string, refreshToken: string): void {\n        this.#authStateService.isUserAuthenticated = true;\n        this.#localStorageService.setItem(\"access_token\", accessToken);\n        this.#localStorageService.setItem(\"refresh_token\", refreshToken);\n        const expiryTime = new Date().getTime() + 3_600_000;\n        this.#localStorageService.setItem(\n            \"token_expiry\",\n            expiryTime.toString(),\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": ["environment", "production", "clientId", "redirectUri", "scope", "authUrl", "tokenUrl", "AuthHTTPService", "_httpClient", "__privateAdd", "inject", "HttpClient", "getAccessToken$", "verifier", "code", "params", "HttpParams", "set", "environment", "clientId", "redirectUri", "__privateGet", "post", "tokenUrl", "headers", "refreshAccessToken$", "refreshToken", "factory", "\u0275fac", "providedIn", "_AuthHTTPService", "environment", "production", "clientId", "redirectUri", "scope", "authUrl", "tokenUrl", "AuthStateService", "_isUserAuthenticated", "_isUserAuthorized", "__privateAdd", "isUserAuthenticated", "__privateGet", "value", "__privateSet", "isUserAuthorized", "factory", "\u0275fac", "providedIn", "_AuthStateService", "KEYS", "LocalStorageService", "setItem", "key", "value", "localStorage", "getItem", "removeItem", "clearLocalStorageItems", "KEYS", "factory", "\u0275fac", "providedIn", "_LocalStorageService", "AuthService", "_activatedRoute", "_authHTTPService", "_authStateService", "_localStorageService", "_router", "_handleAuthentication", "handleAuthentication_fn", "__privateAdd", "inject", "ActivatedRoute", "AuthHTTPService", "AuthStateService", "LocalStorageService", "Router", "generateRandomString", "length", "possible", "crypto", "getRandomValues", "Uint8Array", "reduce", "acc", "x", "sha256$", "plain", "data", "TextEncoder", "encode", "from", "subtle", "digest", "base64encode", "input", "btoa", "String", "fromCharCode", "replace", "redirectToAuthCodeFlow$", "redirectURL", "verifier", "state", "forkJoin", "pipe", "map", "verifierArray", "stateArray", "tap", "authState", "__privateGet", "setItem", "code", "params", "HttpParams", "set", "environment", "clientId", "redirectUri", "scope", "authUrl", "toString", "finalize", "window", "location", "href", "handleAuthCallback$", "queryParams", "switchMap", "getItem", "clearLocalStorageItems", "navigateByUrl", "removeItem", "getAccessTokenWrapper$", "getAccessToken$", "catchError", "isUserAuthenticated", "EMPTY", "access_token", "refresh_token", "__privateMethod", "handlePotentiallyExpiredAccessToken$", "accessToken", "refreshToken", "expiry", "Date", "parseInt", "refreshAccessToken$", "of", "#handleAuthentication", "expiryTime", "getTime", "factory", "\u0275fac", "providedIn", "_AuthService"]
}
